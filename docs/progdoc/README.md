<div align="center"> <h1>Programming documentation</h1> </div>

We will provide an overview of the codebase here as well as mention a couple of notes about some other functionalities surrounding the project.

<div align="center"> <h2><ins>Overview</h2></ins> </div>

Let us give an overview about the structure of the project.

### <ins>Entry points - pages</ins>

The main entry points to the applications are listed in the `pages` directories. The syntax for this is set by NextJs, which states that the page must define a default export of a JSX.Element object to be displayed. The name of the page is determined by the name of the file. Fortunately, Next also supports [dynamic routing](https://nextjs.org/docs/routing/dynamic-routes), which allows us to construct pages for specific items represented by identificators in the syntax of e.g. `[id]`.

We also use API pages for our mock API service. These have the following signature:
```ts
export default async function (request: NextApiRequest, response: NextApiResponse): Promise<void> {...}
```
The result of the function must be saved in the `response` argument.

### <ins>Solid Pod structure</ins>

We require the following Solid Pod structure for our applications:

#### <ins>GPA</ins>

```
Solid Pod
└───privacy
|   │   [id] (privacy token)
|   │   ...
|
└───profile
|   |   card#me (WebId)
|
└───reservations
    └───[id]
        │   reservation
        └───inbox
            │   [id] (notification)
            │   ...
```

#### <ins>PMS</ins>

```
Solid Pod
└───bookingrequests
|   |   [id] notification
|   |   ...

└───dataprotection
|   |   [id] (data protection profile)
|   |   ...
|
└───hotelprofiles
|   |   [id] (hotel profile)
|   |   ...
|
└───privacy
|   │   [id] (privacy token)
|   │   ...
│   └───inbox
|       |   [id] (deletion request)
|       |   ...
|
└───profile
|   |   card#me (WebId)
|
└───reservations
│   └───[id]
│       │   reservation
│       │   pairingToken
|       └───inbox
|           │   [id] (notification)
|           │   ...
|
└───rooms
    |   [id] (room)
    |   ...
```

IDs are generated by the `inrupt` Solid library when the resources are saved in the container.

### <ins>Solid authentication</ins>

Specific implementation functionality is delegated to the `@inrupt/solid-client-authn-browser` library and we define mostly wrappers to tailor the process for our purposes.
The entry point is the login/logout button displayed in the navigation bars of the subprojets. This button takes the user to the `login/` page, which uses the components defined in the `common/components/auth` directory. 

Additionally:
- We check on page reload if we can restore the previous session based on the auth token in effect
- We need to define a workaround on how to load these components as some functions in the auth library call `window`, which is causing issues when the page is pre-rendered on the server side by Next.js. We take advantage of Next's [dynamic loading capability](https://nextjs.org/docs/advanced-features/dynamic-import).

### <ins>Profile synchronization</ins>

One of the requirements of the applications was to showcase the functionality of synchronization between the guest profile copies held at the guest and the hotel. There are two main challenges we solve here:
1. We need to able to react to profile changes made outside the frame of the applications (performed either directly in the Solid Pod or through another Solid app)
2. In order to provide a better overview for the user on what has changed, we need to store the personal information field value somewhere to compare with the new values which are the only ones we can see after the update

The first challenge is solved by subscribing to the resource's WebSocket updates (`common/tracker/tracker`). When the profile is updated, we get a publish notification informing about the change. 
*Note that we also need a way to ignore a message about an update we're going to perform - e.g. when we receive a profile change notice from the counterparty and decide to update our local profile with the change, we must not trigger a profile change event. Fortunately, this is easy to achieve by just ignoring the next message reported by the WebSocket.*

We now know that an update has happened, but we still don't what the update actually is. This is where point 2. comes in effect. When a hotel profile gets created, we can store the field values in memory (`common/tracker/profileCache`) so that we can compare with the new values already present in the Solid Pod. In addition, during the application startup, we can check what profiles are currently contained in the Pod, initialize the cache for them (`tracker-initializer`) and subscribe to the WebSocket notifications. This guarantees that our solution survives an application outage or a page refresh. *Note that it's possible that a field change happens while our application is down, in which case we don't take note of it. This is a known limitation, but we don't expect the PMS application to be down a lot.*

Now that we have both the old and new values of the fields, we can compare what changed and present those to the user for either propagation approval (in the case of the guest) or propagation notice (in the case of the hotel). This is handled mainly by the `components/profilesync/tracker-send-change` snackbar and the components defined in `components/profilesync`. In the latter case, where no approval is required for the propagation, the radio buttons, providing the option to select which changes to send to the counterparty, are disabled.

### <ins>Notifications (communication protocol)</ins>

Notifications are the messaging protocol with the help of which the hotel and the guest communicate. 

They are displayed in a drawer element (`NotificationList` component), which is triggered by the notification icon (`common/components/notification-elements`) contained in the navigation bars. As a QOL improvement, we provide small indicators (so called chips) for each notification displaying its type category and the datetime of when it was created (`common/components/notification-chips`).

We enumerate 8 types of notifications:
1. BookingRequest - can be submitted only by the guest to request a reservation at the hotel
2. ReservationStateChange - a generic notification used either for requesting (from guest to hotel) or confirming (from hotel to guest) a reservation state change - the action carried out depends on the new state
3. FailureReport - sent only by the hotel to the guest to inform them about a failure of one of their requests
4. ProfileModification - contains the fields and their new values of the change performed at the side of the counterparty
5. InitialPairingRequest - sent by the guest to the hotel requesting the pairing of a reservation to a guest Solid Pod (contains the pairing token)
6. PairingRequestWithInformation - the answer for the previous request by the hotel containing the reservation information and the guest profile filled out during offline check-in
7. PrivacyToken - the privacy token sent from the hotel to the guest
8. PrivacyTokenDeletion - either a privacy token deletion request (from guest to hotel) or a deletion notice (from hotel to guest)

Notifications are retrieved from containers whose addresses are different in the GPA (`gpa/consts/inboxList`) and the PMS (`pms/consts/inboxList`).

Besides some common properties parseable from the notification dataset (such as `isProcessed` or `type` flag) we need to be able to define what the notification should display, what actions to perform when it's received or when it's clicked on. These properties differ according to the type of the notification as well as they differ for the GPA and PMS (i.e. the GPA reacts differently when it receives a reservation state change request than the PMS). To handle this, we provide a mapping assigning a parser method based on the type of the notification separately for the GPA (`gpa/consts/parsers`) and the PMS (`pms/consts/parsers`). 

Parser implementation are found in the `incomingCommunications` modules. The symmetrical `outgoingCommunications` modules handle the sending (submitting) side of the transaction.

Symmetrical conversion functions from Solid dataset to TS object and vice versa can be found in the `common/notifications` directory for every notification type.

The `useNotifications` hook can therefore fetch the notifications from the inboxes, parse the common properties and delegate the type specific actions to the parsers. Note that after the execution of the `onReceive()` function of the notification, we set its `isProcessed` flag to `true` to make sure we don't execute multiple times.

### <ins>Mock API service</ins>

As per our requirements, we define a mock API service which will provide the list of the required fields necessary for check-in and creating the data protection profiles. This service will live in our `common` subproject (defined in `common/pages/api`) handling the following two endpoints:
- api/requiredfields (?hotelLocation=...&guestNationality=...)
- api/dataprotection (?hotelLocation=...&guestNationality=...)

During processing, the methods parse the two query parameters submitted and look up the required data in the static `common/api_data.json` file. The result is then returned in JSON format.

### <ins>Setup functionality</ins>

The index page of the `common` subproject serves as the setup page for the application prototypes. In essence, this should be the first stop when the applications are used for the first time.

We provide the functions to set up (or clear) the structure the Solid Pods meant to be used by the applications. This is implemented in modules contained in the `common/setup/populateHotelPod` and `common/setup/populateGuestPod` directories.

Besides the simpler, more manual methods, we attempt to match the WebId of the logged in user to recognize the test accounts meant for this project. If the user logs in with either the guest or hotel test account, we also enable the serialization and deserialization of the sample test data.

The (de)serialization is based on the fact that Solid resources are in effect RDF files. Our conversion is as follows (detailing only serialization here, as the opposite direction is symmetrical to the process):
1. We convert the Solid dataset into RdfJs dataset using a function from the `inrupt` library
2. We use [n3](https://github.com/rdfjs/N3.js/) to convert RdfJs into Quads and write it as string
3. After we gather all resources with appropriate filenames and their contents now represented by a simple string, we zip them up with [jszip](https://stuk.github.io/jszip/) and create a download prompt for the user

Also note the following things regarding the (de)serialization process:
1. Since we make heavy use of datetime objects in our applications, we can't do the saving/loading simply without intervention as the test data would become invalid if it would get loaded a month after it was saved (e.g. a reservation would be shown as active, even though the check-out date is long in the past). Because of this, we need special handling to save relative dates rather than absolute ones:
   - We define a constant base datetime object and calculate the intervals between this base date and the moment the serialization happens and save this
   - Upon deserialization we calculate the same interval between the saved relative date and the base date (which is the same as it was during serialization) and add it to the current moment
2. As we grant permissions to certain containers for the Public, we also need to handle ACL files attached to the Solid resources so these may be reinstated during data loading

### <ins>Data fetching - SWR</ins>

Data fetching is performed using the [SWR](https://swr.vercel.app/) library. The data query works on the following principle
- on the first occassion of the hook call it saves the data retrieved in the cache
- on every subsequent query it immediately returns the cached data to give provide quick feedback while it sends a fetch request to the data storage and returns the fresh query result upon completion

To make it reusable across our codebase, we define custom hooks for the different types of data we need to retrieve (`common/hooks` directory). We override the `fetch` function of SWR for it to be compatible with Solid Pods and parse the results to TS objects.

In order to provide precise feedback to the user, we also returns some flags describing the state of the retrieval. These booleans - such as `isLoading`, `isError` or `isValidating` - help with the interim state of the page until the data can be presented. Additionally, built into our custom hooks is also the capability to display loading bars we dub `loading indicators` to signal when data revalidation is happening in the background. These show up under the navigation bar.

Apart from the general `useSWR` hook, we also use the `mutate` function if we need to trigger a data refetch action.

### <ins>Snackbars</ins>

In order to provide feedback to the user, we use [notistack](https://github.com/iamhosseindhv/notistack) snackbars throughout the application. We enclose the application (`pages/_app`) in a `SnackbarProvider` element and attach an anchor `GlobalSnackbar` element to achieve this.

We use three types of snackbar notifications.

1. Basic snackbar variants of 4 types: info, success, warning and error. These notifications display a simple message to the user in the bottom left corner.
2. Custom snackbars showing various information or informing the user of a background process currently happening. These show in the bottom right corner. We define a generic progress snackbar element (`CustomProgressSnackbar`) which displays a message and a loading bar during the run of a background process (i.e. check-in operation, check-out operation, cancellation, etc.). Since these notifications are essentially React elements, we can also freely call our hooks during them without breaking the [rules of hooks](https://reactjs.org/docs/hooks-rules.html). 
3. Using similar logic as 2., we also use this functionality to display the profile change approval dialogs to the user.

### <ins>Error reporting</ins>

Errors are reported via a basic snackbar, as well as, in case of a more serious error, through the console.

Errors generated during SWR hook calls are handled in an efficient way through the `onError` property in `GlobalSwrConfig`. Note that we make a special case of the "not logged in" messages received as our application are seriously crippled without an authenticated Solid session. We report that the user is not currently logged in through a persisted snackbar error warning.

In case something goes wrong during a component render, we replace the component with a generic error one defined as `ErrorComponent`.

### <ins>RDF vocabularies</ins>

In the spirit of LinkedData, we make an effort to try and reuse appropriate RDF definitions already created. However, in order to define RDF terms for all data classes and properties, we must create a project specific vocabulary as well to fill in the gaps.

We call this ontology `solidhotel`. The RDFS definition is described in Turtle format in file `solidhotel.ttl`. For now, the prefix will reference our GitHub file so all sources are grouped together, but in time we may request a [w3id](https://w3id.org/) address to make it more stable.

To use these custom solutions, we also generate a so-called *convenience object* with the help of the vocabulary [artifact generator](https://github.com/inrupt/artifact-generator). We can generate the helper file with the following command:
```console
> npx @inrupt/artifact-generator generate --inputResources ./solidhotel.ttl
```
Unfortunately, the generator doesn't add the enumeration classes to the resulting file, so some manual additions are necessary. We store the result at `common/solidhotel-vocab` and reference it directly from our code. The RDF terms are strictly only initialized in the `common/vocabularies` folder and we use the created mappings throughout our applications.

### <ins>Other files</ins>

The remaining files not mentioned or referred to above should be fairly self-explanatory, or explained in the documentation comments. These mostly include component definitions (using [Material UI v4](https://mui.com/)) illustrating data or constructing elements for user interactions and utility functions supporting the logic behind the applications (booking, check-in, check-out).

Naming conventions for TypeScript/React sources are unfortunately not clearly defined and they usually vary from project to project. Based on the dependency libraries, we define the following rules for filenames in our applications:
1. `caterpillar-case` for element definitions
2. `PascalCase` for type definitions
3. `camelCase` for everything else

<div align="center"> <h2><ins>Testing</ins></h2> </div>

We use [jest](https://jestjs.io/) in our project to automate the testing of functions, hooks and React components. In addition to this, we use the [ts-jest](https://github.com/kulshekhar/ts-jest) to make our tests more TypeScript friendly.

Element testing is done with the help of [@testing-library](https://testing-library.com/) packages (we also find the [react-hooks-testing-library](https://react-hooks-testing-library.com/) handy to help us test our custom hooks). We simulate user interactions with the [user-event](https://testing-library.com/docs/user-event/intro/) library.

Tests are placed in a `__tests__` folder in each appropriate directory.

To run the tests, use the command:
```console
> npm run test
```
Alternatively, during development you may also use the watch functionality of jest by running:
```console
> npm run test-watch
```

<div align="center"> <h2><ins>Generated documentation</ins></h2> </div>

The documentation is generated using [TypeDoc](https://typedoc.org/).

We use a small workaround to render the HTML result of the modules found in all projects. To process all modules, navigate to the `common` folder and run the following command:
```console
> npx typedoc
```
This will produce the `docs` folder in the current directory with the modules and correct cross reference links from all subprojects.

If you wish to generate the docs for only a specific subproject, you may execute the command above in the corresponding subfolder (`gpa`, `pms` or `spe`). In these cases, only the given project's modules and the shared, common modules are included.

TypeDoc options are provided in the `typedoc.json` files placed in each subproject folder. The options exclude all `*.js` files from generation by default.